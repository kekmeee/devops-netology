Домашняя работа по занятию ""
==

1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой,
   это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить
   strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash
   при старте. Вам нужно найти тот единственный, который относится именно к cd. 
   
<h3>Ответ:</h3>

`chdir("/tmp")`

---

2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
    ````bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ````
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки. 

<h3>Ответ:</h3>

`/usr/share/misc/magic.mgc `

---

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности
   сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение
   продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении
   потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе). 

<h3>Ответ:</h3>

Так как мы знаем, какое приложение (процесс) пишет в удаленный файл, с помощью команды `ps au` узнаем PID этого процесса.
Далее с помощью команды `lsof –p <PID> | grep deleted` мы можем узнать номер дескриптора процесса.
Первое решение, которое приходит в голову это направить туда пустой поток stdin с помощью команды
`echo > /proc/<PID>/fd/<N>`. В таком случае удаленный файл обнулится, но запись в него все равно продолжится. 

В таком случае можно на время сделать скрипт с обнулением этого файла, и скрипт внедрить в планировщик задач с указанием
интервала времени. 

---

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

<h3>Ответ:</h3>

Единственный ресурс, который занимают зомби-процессы это место в списке процессов. Количество максимально возможных
запущенных процессов можно увидеть, выполнив команду cat /proc/sys/kernel/threads-max.

---

5. В iovisor BCC есть утилита opensnoop: 
    ````bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc 
    ````
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools
для Ubuntu 20.04. 

<h3>Ответ:</h3>

````bash
admsec@dev:~$ sudo opensnoop-bpfcc -d 1 
PID    COMM               FD ERR PATH 
772    irqbalance          6   0 /proc/interrupts 
772    irqbalance          6   0 /proc/stat 
772    irqbalance          6   0 /proc/irq/58/smp_affinity 
772    irqbalance          6   0 /proc/irq/57/smp_affinity 
772    irqbalance          6   0 /proc/irq/56/smp_affinity 
772    irqbalance          6   0 /proc/irq/56/smp_affinity 
772    irqbalance          6   0 /proc/irq/19/smp_affinity 
772    irqbalance          6   0 /proc/irq/19/smp_affinity 
772    irqbalance          6   0 /proc/irq/1/smp_affinity 
772    irqbalance          6   0 /proc/irq/8/smp_affinity 
772    irqbalance          6   0 /proc/irq/12/smp_affinity 
772    irqbalance          6   0 /proc/irq/14/smp_affinity 
772    irqbalance          6   0 /proc/irq/15/smp_affinity 
````

---

6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается
   альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС. 

<h3>Ответ:</h3>

Команда uname использует системный вызов `uname()`. После изучения man’а системного вызова uname(), выяснил, что
альтернативное местоположение информации о версии ядра и релиза ОС можно узнать в:

`/proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}`

Цитата из man’а: "Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease,
version, domainname}."

Не уверен насколько это будет однотипно, но ведь можно посмотреть эту информацию через команду cat /proc/version и
соответственно системного вызова `uname()` в таком случае не будет. 

---

7. Чем отличается последовательность команд через ; и через && в bash? Например: 
    ````bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi 
    Hi 
    root@netology1:~# test -d /tmp/some_dir && echo Hi 
    root@netology1:~# 
    ````
    Есть ли смысл использовать в bash &&, если применить set -e? 

<h3>Ответ:</h3>

В первом случае, команды, разделенные символом `;`, выполняются последовательно одна за другой. При чем оболочка будет
ждать завершения каждой команды. Итоговый статус такой последовательности – это статус последней выполненной команды.  

Во втором случае, команды, разделенные символом `&&`, выполняются следующим образом: есть команда comm1 && comm2. В
таком случае команда comm2 выполнится тогда и только тогда, когда команда comm1 выполнится со статусов 0 (успешное
выполнение программы).  

В случае использования в bash `&&` и `set -e` команды будут выполняться следующим образом: есть команда `set -e comm1 &&
comm2`. В таком случае команда comm2 будет выполнена в любом случае, так как в случае, если команда comm1 вернет статус
отличный от нуля, то команда `set -e` (аргумент `-e` указывает выполнить выход, если команда вернет не нулевой статус)
принудительно завершит команду comm1 и в любом случае вернет статус 0.  

---

8. Из каких опций состоит режим `bash set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

<h3>Ответ:</h3>

Аргументы команды set: 
- `e` – выполнять выход, если команда заканчивается с ненулевым статусом; 
- `u` – при подстановки неопределенные переменные помечать как ошибки; 
- `x` – печатать команды с их аргументами по мере их выполнения 
- `o pipefail` – возвращать в качестве значения из пайплайна статус последней команды с ненулевым значением или
  возвращать 0, если ни одна из команд не вышла с ненулевым статусом. 

Возможные причины, почему этот режим может быть полезен: 
1. в случае, если в скрипте одна из команд завершится с ошибкой, аргумент `-e` поможет нам пропустить ее и продолжить
   выполнять скрипт; 
2. аргумент `-u` дает возможность использовать только те переменные, которые явно определены, а все неизвестные будут
   отбрасываться. Как я понимаю, если появится неопределенная переменная, то команда выполниться с ошибкой и в таком
   случае нам помогает аргумент `-e`, как указано в описании выше; 
3. аргумент `-x` используется как вспомогательная функция для понимания на каком этапе выполнения скрипта та или иная
   команда в скрипте заканчивается, например, с ошибкой. То есть мы можем увидеть ход событий при выполнении скрипта; 
4. опция `-o pipefail` позволяет нам быть уверенными, что при использовании пайплайнов на выходе мы получим либо статус
   0 и скрипт продолжит свое выполнение в штатном режиме, либо статус будет ненулевой и аргумент «-e» пропустить эти
   команды в пайплайне и скрипт продолжит свое исполнение.  

---

9. Используя `-o stat` для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps
   ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов.
   Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными). 

<h3>Ответ:</h3>

Наиболее часто встречающиеся статусы процессов: 
- `S` – статус ожидания завершения события; 
- `I` – статус неактивного процесса; 

Дополнительные статусы процессов: 
- статусы высокого (`<`) и низкого (`N`) приоритета процесса; 
- статус блокированного участка памяти (`L`) процесса в данный момент времени, а также для пользовательского ввода/вывода; 
- статус лидера процесса (`s`) (я так понимаю это статус родителя); 
- статус многопоточного процесса (`l`); 
- статус, указывающий, что процесс находится на переднем плане (`+`). 