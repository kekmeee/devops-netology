Домашняя работа по занятию "6.6. Troubleshooting"
==

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

<h3>Ответ:</h3>

Для прерывания операции можно использовать метод `db.killOp()`, где в качестве аргумента необходим ID операции.
Чтобы определить ID операции можно использовать  `$currentOp` или метод `db.currentOp()`.

Для решения проблемы с долгими (зависающими) запросами в MongoDB можно использовать метод `maxTimeMS()`, лимит по
времени для выполнения операции.

---

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

<h3>Ответ:</h3>

Не совсем понял вопрос. Если можно, то при отправке на доработку, дайте, пожалуйста, пояснения к задаче. Не понял про
"отношение количества записанных key-value значений к количеству истёкших значений".
Возможно, что Redis блокирует операции записи из-за того, что он является однопоточным. То есть,
не успевает записывать все данные, которые к нему поступают, и получается, что образуется очередь.

---

## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

<h3>Ответ:</h3>

Поиск проблемы необходимо выполнять через `slow_log`. Необходимо чтобы `slow_log` был включен и тогда в логах можно
наблюдать медленные запросы. В случае возникновения таких запросов, их необходимо оптимизировать.

Возможно, что при попытке получения данных, должно передаться большое количество строк из БД. И в таком случае требуется
некоторое время для чтения этих строк. Для контроля времени чтения данных используется системная переменная сервера
`net_read_timeout`. Возможно, что в переменной указано недостаточно времени для чтения. Для этого нужно увеличить время
чтения до разрыва соединения.

Можно для данной операции использовать индексы и, в таком случае будет скорость получения данных должна быть быстрее.

---

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

<h3>Ответ:</h3>

Данная запись говорит о нехватке выделяемой памяти для процессов, и в следствии чего киллер out of memory выполняет
удаление высоконагруженных процессов, чтобы предотвратить сбой системы в целом.
К решению задачи можно подойти с нескольких сторон:
- можно увеличить объем памяти, если это возможно (например swap, но в таком случае возможно уменьшение производительности,
  так как скорость чтения/записи swap меньше, чем из памяти напрямую)
- можно настроить параметр ядра `vm.overcommit_memory`, который отвечает за резервирование памяти для процессов.
  Рекомендуется для параметра устанавливать значение `2` (ядро не будет резервировать больше памяти, чем указано в
  параметре overcommit_ratio)